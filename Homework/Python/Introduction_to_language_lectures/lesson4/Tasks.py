
# data = [1, 2, 3, 5, 8, 15, 23, 38]
# res = list()
# for i in data:
#     if not i % 2:
#         res.append((i, i * i))
# print(res)


# def select(f, col):
#     return [f(x) for x in col] # мы применяем функцию f(x) к каждому элементу col

# def where(f, col):
#     return [x for x in col if f(x)] # она будет возвращать те х пробежавшись по каждому элементу col, но с определённым условием f(x).

# data = [1, 2, 3, 5, 8, 15, 23, 38]
# res = select(int, data) # мы приводим все значения к целочисленному значению списка data
# print(res)
# res = where(lambda x: not x % 2, res) # выводит те числа, которые удовлетворяют условию
# print(res)
# res = select(lambda x: (x, x**2), res) # выводит те значения которые удовлетворяют условию
# print(res)


# Функция map - принимает на вход 2 аргумента, первый - это функция которую мы передаём, и второй аргумент - это объект

# list_1 = [x for x in range(1, 20)]
# print(list_1)
# list_1 = list(map(lambda x: x + 10, list_1))
# print(list_1)


# Задача: С клавиатуры вводится некий набор чисел, в качестве разделителя используется пробел.
# Этот набор чисел будет считан в качестве строки.
# Как превратить list строк в list чисел?

# data = "15 156 96 3 5 8 52 5"

# data = list(map(int, data.split()))
# print(data)

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


# data = [1, 2, 3, 5, 8, 15, 23, 38]
# res = map(int, data)
# print(res)
# res = filter(lambda x: x % 2 == 0, res)
# print(res)
# res = list(map(lambda x: (x, x**2), res))
# print(res)

# select полная копия функции map, поэтому просто заменили select на map

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# data = '15 156 96 3 5 8 52 5'
# # print(data)
# # data = data.split()
# # print(data)
# data = list(map(int, data.split()))
# print(data)

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# Функция filter фильтрует какие то значения. На вход принимает 2 аргумента: функция и объект. Она будет выводить те значения кторые удовлетворяют условию функции.

# data = [15, 65, 9, 36, 175]
# res = list(filter(lambda x: x % 10 == 5, data))
# print(res)

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    
# data = [1, 2, 3, 5, 8, 15, 23, 38]
# res = map(int, data)
# print(res)
# res = filter(lambda x: x % 2 == 0, res)
# print(res)
# res = list(map(lambda x: (x, x**2), res))
# print(res)

# Функция filter полная копия функции where. Поэтому просто меняем её.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    
# Функция zip() применяется к набору итерируемых объектов и возвращает итератор с кртежами из элементов входных данных

# zip ([1, 2, 3], ["о", "д", "т"], ["f" "s" "t"]

# ["1" "o" "f"], ["2" "д" 's'], ["3" "т" "t"])
# На выходе получаем набор данных, состоящий из элементов соответствующих исходному набор

# # Берёт первый элемент из первого списка, берёт первый элемент второго списка и т.д и составляет кортеж.
# Замечание: функция пробегает по минимальному входящему набору


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\///////////////////////////////////////////////////////////////

# # Функция enumerate() применяется к итерируемому объекту и возвращает новый итератор с кортежами из индекса и элементов входных данных
# Она позволяет пронумеровать набор данных

# enumerate(["Казань", "Смоленск", "Рыбки", "Чикаго"])
# # [(0, "Казань"), (1, "Смоленск"), (2, "Рыбки"), (3, "Чикаго")]


# users = ["user1", "users2", "user3"]
# res = list(enumerate(users))
# print(res)

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\///////////////////////////////////////////////////////////////

# Файлы. 
# 
# Файлы в текстовом формате используются для 
# - Хранения данных
# - Передачи данных в клиент-серверных проектах
# - Хранение конфигов
# - Логирование действий

# Что нужно для работы с файлами:
# 1. Завести переменную, которая будет связана с этим текстовым файлом
# 2. Указать путь к файлу
# 3. Указать, в каком режиме мы будем работать с файлом

# Варианты режима (мод):
#     а - (append) - открытие для добавления данных
#     - Позволяет дописывать что то в имеющийся файл
#     - Если вы попробуете дозаписать что то в несуществующий файл, то файл будет создан и в него начнётся запись.
   
    # r - (read) - открытие для чтения данных
    # - Позволяет читать данные из файла.
    # - Если вы попробуете считать данные из файла, которого нет, программа выдаст ошибку.
    
    # w - (write) - открытие для записи данных
    # - Позволяет записывать данные и создавать файл, если его нет.

    # w+ 
    # - Позволяет открывать файл для записи и читать из него
    # - Если файла нет, он будет создан
    
    # # r+ 
    # Позволяет открывать файл для чтения и дозаписывать в него 
    # Если файла нет, то программа выдаст ошибку
    
# colors = ["red", "green", "blue"]
# data = open('file.txt', 'a', encoding='utf-8') # здесь указываем режим, в котором будет работать
# data.writelines(colors) # разделителей не будет. Данные будут каждый раздобавляться
# data.close 

# with open('file.txt', 'w') as data: # с with можно файл не закрывать, т.к. он закроется автоматически завершения.
#     data.write('line 1\n')
#     data.write('line 2\n') # данные будут каждый раз перезаписываться, не добавляться
    
# path = 'file.txt'
# data = open(file.txt, 'r')
# for line in data:
#     print(line)
# data.close()

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\///////////////////////////////////////////////////////////////

# Модуль OS

# Он предоставляет множество функций для работы с операционной системой, причём их поведение, не зависит от операционной системы, поэтому программы остаются переносимыми.
# Для того чтобы начать работать с данным модулем надо импортировать в свою программу
# import os

# os.chdir(path) - смена текущей директории
# os.chdir('C:/Users/79190/PycharmProjects/GB')

# os.getcwd() - текущая рабочая директория
# print(os.getcwd()) # 'C:\Users\79190\PycharmProjects\webprojects'

# os.path - является вложенным модулем в модуль os и реализует
# некоторые полезные функции для работы с путями, такие как:
    
# os.path.basename(path) - базовое имя пути
# print(os.path.basename('C:\Users\79190\PycharmProjects\webprojects\main.py')) вывод будет - main.py

# os.path.abspath(path) - возвращает нормальный абсолютный путь.
# print(os.path.abspath('main.py')) вывод будет - 'C:\Users\79190\PycharmProjects\webprojects\main.py'

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\///////////////////////////////////////////////////////////////

# Модуль shutil
# Он содержит набор функций высого уровня для обработки файлов, групп файлов, и папок.
# В частности, доступны функции копировать, перемещать и удалять файлы и папки. Часто используются с модулем os

# import shutil

# shutil.copyfile(src, dst) - копирует содержимое (но не метаданные) файла src в файл dst

# shutil.copy(src, dst) - копирует содержимое файла src в файл или папку dst

# shutil.rmtree(path) - Удаляет текущую директорию и все поддиректории;
# path должен указать на директорию, а не на символическую ссылку.
